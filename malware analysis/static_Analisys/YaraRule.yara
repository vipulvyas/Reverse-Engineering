rule suspicious_strings
{
strings:
	$a = "Synflooding"
	$b = "Portscanner"
	$c = "Keylogger"
condition:
	($a or $b or $c)
}

#with ascii and Unicode

rule suspicious_strings
{
strings:
	$a = "Synflooding" ascii wide nocase
	$b = "Portscanner" ascii wide nocase
	$c = "Keylogger" ascii wide nocase
condition:
	($a or $b or $c)
}

#check Exe

rule suspicious_strings
{
strings:
	$mz = {4D 5A}
	$a = "Synflooding" ascii wide nocase
	$b = "Portscanner" ascii wide nocase
	$c = "Keylogger" ascii wide nocase
condition:
	($mz at 0) and ($a or $b or $c)
}

#executable file containing an embedded MicrosoftOffice document in it

rule embedded_office_document
{
meta:
	description = "Detects embedded office document"
strings:
	$mz = { 4D 5A }
	$a = { D0 CF 11 E0 A1 B1 1A E1 }
condition:
	($mz at 0) and $a in (1024..filesize)
}

#serial number can be used as a signature to detect samples that have the same digital certificate

rule mal_digital_cert_9002_rat
{
meta:
	description = "Detects malicious digital certificates used by RAT 9002"
	ref = "http://blog.cylance.com/another-9002-trojan-variant"
strings:
	$mz = { 4D 5A }
	$a = { 45 6e 96 7a 81 5a a5 cb b9 9f b8 6a ca 8f 7f 69 }
condition:
	($mz at 0) and ($a in (1024..filesize))
}


#Packer Detector

[UPX 2.90 (LZMA)]
signature = 60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF EB 10 90 90 90
90 90 90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00
00 00 01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB
ep_only = true   (this is for "Exeinfo PE" should only check for the signature at the program's address of entry point)

(new version support import pe)
import "pe"
rule UPX_290_LZMA
{
meta:
	description = "Detects UPX packer 2.90"
	ref = "userdb.txt file from the Exeinfo PE"
strings:
	$a = { 60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF EB 10 90 90 90
	90 90 90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00
	00 00 01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB }
condition:
	$a at pe.entry_point
}

(without pe)
rule UPX_290_LZMA
{
meta:
	description = "Detects UPX packer 2.90"
	ref = "userdb.txt file from the Exeinfo PE"
strings:
	$a = { 60 BE ?? ?? ?? ?? 8D BE ?? ?? ?? ?? 57 83 CD FF EB 10 90 90 90
	90 90 90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC 11 DB 72 ED B8 01 00
	00 00 01 DB 75 07 8B 1E 83 EE FC 11 DB 11 C0 01 DB }
condition:
	$a at entrypoint
}




#YARA rule detects Communication of different variants of the Gh0stRAT malware:

rule Gh0stRat_communications
{
meta:
	Description = "Detects the Gh0stRat communication in Packet Captures"
strings:
	$gst1 = {47 68 30 73 74 ?? ?? 00 00 ?? ?? 00 00 78 9c}
	$gst2 = {63 62 31 73 74 ?? ?? 00 00 ?? ?? 00 00 78 9c}
	$gst3 = {30 30 30 30 30 30 30 30 ?? ?? 00 00 ?? ?? 00 00 78 9c}
	$gst4 = {45 79 65 73 32 ?? ?? 00 00 ?? ?? 00 00 78 9c}
	$gst5 = {48 45 41 52 54 ?? ?? 00 00 ?? ?? 00 00 78 9c}
	$any_variant = /.{5,16}\x00\x00..\x00\x00\x78\x9c/
condition:
	any of ($gst*) or ($any_variant)
}

-Running the preceding rule on a directory containing network packet captures (pcaps),detected the GhostRAT pattern in some of the pcaps as shown here:
	$ yara ghost_communications.yara pcaps/
	Gh0stRat_communications pcaps//Gh0st.pcap
	Gh0stRat_communications pcaps//cb1st.pcap
	Gh0stRat_communications pcaps//HEART.pcap


#After you analyze the malware, you can create signatures to identify its components; the following shows an example YARA rule to detect the driver and the DLL components of Darkmegi Rootkit:

rule Darkmegi_Rootkit
{
meta:
	Description = "Detects the kernel mode Driver and Dll component of
Darkmegi/waltrodock rootkit"
strings:
$drv_str1 = "com32.dll"
$drv_str2 = /H:\\RKTDOW~1\\RKTDRI~1\\RKTDRI~1\\objfre\\i386\\RktDriver.pdb/
$dll_str1 = "RktLibrary.dll"
$dll_str2 = /\\\\.\\NpcDark/
$dll_str3 = "RktDownload"
$dll_str4 = "VersionKey.ini"
condition:
	(all of them) or (any of ($drv_str*)) or (any of ($dll_str*))
}


#For generating YARA rules, you might consider using Florian Roth's yarGen ( https://github.com/Neo23x0/yarGen ) or Joe Security's YARA rule generator ( https://www.yara-generator.net/ ).
